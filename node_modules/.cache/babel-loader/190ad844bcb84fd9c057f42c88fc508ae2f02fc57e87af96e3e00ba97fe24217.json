{"ast":null,"code":"import _slicedToArray from \"/Users/vivian/Desktop/today-i-learned/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"/Users/vivian/Desktop/today-i-learned/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/vivian/Desktop/today-i-learned/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport PostgrestQueryBuilder from './PostgrestQueryBuilder';\nimport PostgrestFilterBuilder from './PostgrestFilterBuilder';\nimport { DEFAULT_HEADERS } from './constants';\n/**\n * PostgREST client.\n *\n * @typeParam Database - Types for the schema from the [type\n * generator](https://supabase.com/docs/reference/javascript/next/typescript-support)\n *\n * @typeParam SchemaName - Postgres schema to switch to. Must be a string\n * literal, the same one passed to the constructor. If the schema is not\n * `\"public\"`, this must be supplied manually.\n */\nvar PostgrestClient = /*#__PURE__*/function () {\n  // TODO: Add back shouldThrowOnError once we figure out the typings\n  /**\n   * Creates a PostgREST client.\n   *\n   * @param url - URL of the PostgREST endpoint\n   * @param options - Named parameters\n   * @param options.headers - Custom headers\n   * @param options.schema - Postgres schema to switch to\n   * @param options.fetch - Custom fetch\n   */\n  function PostgrestClient(url) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$headers = _ref.headers,\n      headers = _ref$headers === void 0 ? {} : _ref$headers,\n      schema = _ref.schema,\n      fetch = _ref.fetch;\n    _classCallCheck(this, PostgrestClient);\n    this.url = url;\n    this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS), headers);\n    this.schemaName = schema;\n    this.fetch = fetch;\n  }\n  /**\n   * Perform a query on a table or a view.\n   *\n   * @param relation - The table or view name to query\n   */\n  _createClass(PostgrestClient, [{\n    key: \"from\",\n    value: function from(relation) {\n      var url = new URL(\"\".concat(this.url, \"/\").concat(relation));\n      return new PostgrestQueryBuilder(url, {\n        headers: Object.assign({}, this.headers),\n        schema: this.schemaName,\n        fetch: this.fetch\n      });\n    }\n    /**\n     * Select a schema to query or perform an function (rpc) call.\n     *\n     * The schema needs to be on the list of exposed schemas inside Supabase.\n     *\n     * @param schema - The schema to query\n     */\n  }, {\n    key: \"schema\",\n    value: function schema(_schema) {\n      return new PostgrestClient(this.url, {\n        headers: this.headers,\n        schema: _schema,\n        fetch: this.fetch\n      });\n    }\n    /**\n     * Perform a function call.\n     *\n     * @param fn - The function name to call\n     * @param args - The arguments to pass to the function call\n     * @param options - Named parameters\n     * @param options.head - When set to `true`, `data` will not be returned.\n     * Useful if you only need the count.\n     * @param options.count - Count algorithm to use to count rows returned by the\n     * function. Only applicable for [set-returning\n     * functions](https://www.postgresql.org/docs/current/functions-srf.html).\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     */\n  }, {\n    key: \"rpc\",\n    value: function rpc(fn) {\n      var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        _ref2$head = _ref2.head,\n        head = _ref2$head === void 0 ? false : _ref2$head,\n        count = _ref2.count;\n      var method;\n      var url = new URL(\"\".concat(this.url, \"/rpc/\").concat(fn));\n      var body;\n      if (head) {\n        method = 'HEAD';\n        Object.entries(args).forEach(function (_ref3) {\n          var _ref4 = _slicedToArray(_ref3, 2),\n            name = _ref4[0],\n            value = _ref4[1];\n          url.searchParams.append(name, \"\".concat(value));\n        });\n      } else {\n        method = 'POST';\n        body = args;\n      }\n      var headers = Object.assign({}, this.headers);\n      if (count) {\n        headers['Prefer'] = \"count=\".concat(count);\n      }\n      return new PostgrestFilterBuilder({\n        method: method,\n        url: url,\n        headers: headers,\n        schema: this.schemaName,\n        body: body,\n        fetch: this.fetch,\n        allowEmpty: false\n      });\n    }\n  }]);\n  return PostgrestClient;\n}();\nexport { PostgrestClient as default };","map":{"version":3,"names":["PostgrestQueryBuilder","PostgrestFilterBuilder","DEFAULT_HEADERS","PostgrestClient","url","_ref","arguments","length","undefined","_ref$headers","headers","schema","fetch","_classCallCheck","Object","assign","schemaName","_createClass","key","value","from","relation","URL","concat","rpc","fn","args","_ref2","_ref2$head","head","count","method","body","entries","forEach","_ref3","_ref4","_slicedToArray","name","searchParams","append","allowEmpty","default"],"sources":["/Users/vivian/Desktop/today-i-learned/node_modules/@supabase/postgrest-js/src/PostgrestClient.ts"],"sourcesContent":["import PostgrestQueryBuilder from './PostgrestQueryBuilder'\nimport PostgrestFilterBuilder from './PostgrestFilterBuilder'\nimport PostgrestBuilder from './PostgrestBuilder'\nimport { DEFAULT_HEADERS } from './constants'\nimport { Fetch, GenericSchema } from './types'\n\n/**\n * PostgREST client.\n *\n * @typeParam Database - Types for the schema from the [type\n * generator](https://supabase.com/docs/reference/javascript/next/typescript-support)\n *\n * @typeParam SchemaName - Postgres schema to switch to. Must be a string\n * literal, the same one passed to the constructor. If the schema is not\n * `\"public\"`, this must be supplied manually.\n */\nexport default class PostgrestClient<\n  Database = any,\n  SchemaName extends string & keyof Database = 'public' extends keyof Database\n    ? 'public'\n    : string & keyof Database,\n  Schema extends GenericSchema = Database[SchemaName] extends GenericSchema\n    ? Database[SchemaName]\n    : any\n> {\n  url: string\n  headers: Record<string, string>\n  schemaName?: SchemaName\n  fetch?: Fetch\n\n  // TODO: Add back shouldThrowOnError once we figure out the typings\n  /**\n   * Creates a PostgREST client.\n   *\n   * @param url - URL of the PostgREST endpoint\n   * @param options - Named parameters\n   * @param options.headers - Custom headers\n   * @param options.schema - Postgres schema to switch to\n   * @param options.fetch - Custom fetch\n   */\n  constructor(\n    url: string,\n    {\n      headers = {},\n      schema,\n      fetch,\n    }: {\n      headers?: Record<string, string>\n      schema?: SchemaName\n      fetch?: Fetch\n    } = {}\n  ) {\n    this.url = url\n    this.headers = { ...DEFAULT_HEADERS, ...headers }\n    this.schemaName = schema\n    this.fetch = fetch\n  }\n\n  from<\n    TableName extends string & keyof Schema['Tables'],\n    Table extends Schema['Tables'][TableName]\n  >(relation: TableName): PostgrestQueryBuilder<Schema, Table>\n  from<ViewName extends string & keyof Schema['Views'], View extends Schema['Views'][ViewName]>(\n    relation: ViewName\n  ): PostgrestQueryBuilder<Schema, View>\n  from(relation: string): PostgrestQueryBuilder<Schema, any>\n  /**\n   * Perform a query on a table or a view.\n   *\n   * @param relation - The table or view name to query\n   */\n  from(relation: string): PostgrestQueryBuilder<Schema, any> {\n    const url = new URL(`${this.url}/${relation}`)\n    return new PostgrestQueryBuilder<Schema, any>(url, {\n      headers: { ...this.headers },\n      schema: this.schemaName,\n      fetch: this.fetch,\n    })\n  }\n\n  /**\n   * Select a schema to query or perform an function (rpc) call.\n   *\n   * The schema needs to be on the list of exposed schemas inside Supabase.\n   *\n   * @param schema - The schema to query\n   */\n  schema<DynamicSchema extends string & keyof Database>(\n    schema: DynamicSchema\n  ): PostgrestClient<\n    Database,\n    DynamicSchema,\n    Database[DynamicSchema] extends GenericSchema ? Database[DynamicSchema] : any\n  > {\n    return new PostgrestClient<\n      Database,\n      DynamicSchema,\n      Database[DynamicSchema] extends GenericSchema ? Database[DynamicSchema] : any\n    >(this.url, {\n      headers: this.headers,\n      schema,\n      fetch: this.fetch,\n    })\n  }\n\n  /**\n   * Perform a function call.\n   *\n   * @param fn - The function name to call\n   * @param args - The arguments to pass to the function call\n   * @param options - Named parameters\n   * @param options.head - When set to `true`, `data` will not be returned.\n   * Useful if you only need the count.\n   * @param options.count - Count algorithm to use to count rows returned by the\n   * function. Only applicable for [set-returning\n   * functions](https://www.postgresql.org/docs/current/functions-srf.html).\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  rpc<\n    FunctionName extends string & keyof Schema['Functions'],\n    Function_ extends Schema['Functions'][FunctionName]\n  >(\n    fn: FunctionName,\n    args: Function_['Args'] = {},\n    {\n      head = false,\n      count,\n    }: {\n      head?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<\n    Schema,\n    Function_['Returns'] extends any[]\n      ? Function_['Returns'][number] extends Record<string, unknown>\n        ? Function_['Returns'][number]\n        : never\n      : never,\n    Function_['Returns']\n  > {\n    let method: 'HEAD' | 'POST'\n    const url = new URL(`${this.url}/rpc/${fn}`)\n    let body: unknown | undefined\n    if (head) {\n      method = 'HEAD'\n      Object.entries(args).forEach(([name, value]) => {\n        url.searchParams.append(name, `${value}`)\n      })\n    } else {\n      method = 'POST'\n      body = args\n    }\n\n    const headers = { ...this.headers }\n    if (count) {\n      headers['Prefer'] = `count=${count}`\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url,\n      headers,\n      schema: this.schemaName,\n      body,\n      fetch: this.fetch,\n      allowEmpty: false,\n    } as unknown as PostgrestBuilder<Function_['Returns']>)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}